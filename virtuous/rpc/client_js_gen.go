package rpc

import (
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientJSTemplate = template.Must(template.New("virtuous-rpc-js").Parse(`// Code generated by Virtuous runtime; DO NOT EDIT.

/**
 * @typedef {Object} AuthOptions
 * @property {string} [auth]
 */

/**
 * @template E
 * @extends {Error}
 */
export class RPCError extends Error {
	/**
	 * @param {number} status
	 * @param {E|null} body
	 * @param {string} message
	 */
	constructor(status, body, message) {
		super(message)
		this.status = status
		this.body = body
	}
}

// Type definitions
{{- range $object := .Objects }}
/**
 * @typedef {Object} {{ $object.Name }}
{{- range $field := $object.Fields }}
 * @property{{- if $field.Nullable }} {{ printf "{%s|null}" $field.Type }}{{ else }} {{ printf "{%s}" $field.Type }}{{ end }} {{ if $field.Optional }}[{{ $field.Name }}]{{ else }}{{ $field.Name }}{{ end }}{{ if $field.Doc }} - {{ $field.Doc }}{{ end }}
{{- end }}
 */

{{- end }}

/**
 * @param {string} [basepath="/"]
 * @returns {object}
 */
export function createClient(basepath = "/") {
	return {
{{- range $service := .Services }}
		{{ $service.Name }}: {
{{- range $method := $service.Methods }}
			/**
{{- if $method.HasBody }}
			 * @param { {{- if $method.RequestType }}{{ $method.RequestType }}{{ else }}any{{ end }} } request
			 * @param {AuthOptions} [options]
{{- else }}
			 * @param {AuthOptions} [options]
{{- end }}
			 * @returns {Promise<{{- if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}any{{ end }}>}
			 */
			async {{ $method.Name }}({{ if $method.HasBody }}request, {{ end }}options) {
				const headers = {
					"Accept": "application/json",
					"Content-Type": "application/json",
				}
				let url = basepath + "{{ $method.Path }}"
{{- if $method.HasAuth }}
				const authValue = options && options.auth
				if (authValue) {
{{- if eq $method.Auth.In "header" }}
					headers["{{ $method.Auth.Param }}"] = {{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue
{{- end }}
{{- if eq $method.Auth.In "query" }}
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + encodeURIComponent("{{ $method.Auth.Param }}") + "=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
					document.cookie = "{{ $method.Auth.Param }}=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue) + "; path=/"
{{- end }}
				}
{{- end }}
				const response = await fetch(url, {
					method: "POST",
					headers,
{{- if $method.HasAuth }}
{{- if eq $method.Auth.In "cookie" }}
					credentials: "same-origin",
{{- end }}
{{- end }}
{{- if $method.HasBody }}
					body: JSON.stringify(request),
{{- end }}
				})
				const text = await response.text()
				let json = null
				if (text) {
					try {
						json = JSON.parse(text)
					} catch (e) {
						if (!response.ok) {
							throw new RPCError(response.status, null, response.status + " " + response.statusText)
						}
						throw e
					}
				}
				if (!response.ok) {
					throw new RPCError(response.status, json, response.status + " " + response.statusText)
				}
				return json
			},
{{- end }}
		},
{{- end }}
	}
}
`))

// WriteClientJS writes a runtime-generated JS client to w.
func (r *Router) WriteClientJS(w io.Writer) error {
	body, err := r.clientJSBody()
	if err != nil {
		return err
	}
	hash := hashClientBytes(body)
	if _, err := io.WriteString(w, "// Virtuous client hash: "+hash+"\n"); err != nil {
		return err
	}
	_, err = w.Write(body)
	return err
}

// WriteClientJSFile writes a runtime-generated JS client to the file at path.
func (r *Router) WriteClientJSFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientJS(f)
}

// WriteClientJSHash writes the hash of the JS client output to w.
func (r *Router) WriteClientJSHash(w io.Writer) error {
	hash, err := r.clientJSHash()
	if err != nil {
		return err
	}
	_, err = io.WriteString(w, hash)
	return err
}

// ServeClientJS writes a runtime-generated JS client as an HTTP response.
func (r *Router) ServeClientJS(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/javascript")
	if err := r.WriteClientJS(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

// ServeClientJSHash writes the hash of the JS client as an HTTP response.
func (r *Router) ServeClientJSHash(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	if err := r.WriteClientJSHash(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

func (r *Router) clientJSBody() ([]byte, error) {
	spec := buildClientSpec(r.Routes(), r.typeOverrides)
	return renderClientTemplate(clientJSTemplate, spec)
}

func (r *Router) clientJSHash() (string, error) {
	body, err := r.clientJSBody()
	if err != nil {
		return "", err
	}
	return hashClientBytes(body), nil
}
