package virtuous

import (
	"io"
	"text/template"
)

var clientTSTemplate = template.Must(template.New("virtuous-ts").Parse(`// Code generated by Virtuous runtime; DO NOT EDIT.

export type AuthOptions = {
	auth?: string
}

export function createClient(basepath: string = "/") {
	return {
{{- range $service := .Services }}
		{{ $service.Name }}: {
{{- range $method := $service.Methods }}
			async {{ $method.Name }}({{ if $method.PathParams }}pathParams: { {{- range $param := $method.PathParams }}{{ $param }}: string; {{- end }} }, {{ end }}{{ if $method.HasBody }}request: any, {{ end }}options?: AuthOptions) {
				const headers: Record<string, string> = {
					"Accept": "application/json",
					"Content-Type": "application/json",
				}
				let url = basepath + "{{ $method.Path }}"
{{- if $method.PathParams }}
				if (!pathParams) {
					throw new Error("pathParams is required")
				}
{{- range $param := $method.PathParams }}
				url = url.replace("{{ printf "{%s}" $param }}", encodeURIComponent(String(pathParams.{{ $param }})))
{{- end }}
{{- end }}
{{- if $method.HasAuth }}
				const authValue = options && options.auth
				if (authValue) {
{{- if eq $method.Auth.In "header" }}
					headers["{{ $method.Auth.Param }}"] = {{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue
{{- end }}
{{- if eq $method.Auth.In "query" }}
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + encodeURIComponent("{{ $method.Auth.Param }}") + "=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
					document.cookie = "{{ $method.Auth.Param }}=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue) + "; path=/"
{{- end }}
				}
{{- end }}
				const response = await fetch(url, {
					method: "{{ $method.HTTPMethod }}",
					headers,
{{- if $method.HasAuth }}
{{- if eq $method.Auth.In "cookie" }}
					credentials: "same-origin",
{{- end }}
{{- end }}
{{- if $method.HasBody }}
					body: JSON.stringify(request || {}),
{{- end }}
				})
				const text = await response.text()
				let json: any = null
				if (text) {
					try {
						json = JSON.parse(text)
					} catch (e) {
						if (!response.ok) {
							throw new Error(response.status + " " + response.statusText)
						}
						throw e
					}
				}
				if (!response.ok) {
					if (json && json.error) {
						throw new Error(json.error)
					}
					throw new Error(response.status + " " + response.statusText)
				}
				return json || {}
			},
{{- end }}
		},
{{- end }}
	}
}
`))

// WriteClientTS writes a runtime-generated TS client to w.
func (r *Router) WriteClientTS(w io.Writer) error {
	spec := buildClientSpec(r.Routes(), r.typeOverrides)
	return clientTSTemplate.Execute(w, spec)
}
