package virtuous

import (
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientJSTemplate = template.Must(template.New("virtuous-js").Parse(`// Code generated by Virtuous runtime; DO NOT EDIT.

/**
 * @typedef {Object} AuthOptions
 * @property {string} [auth]
 */

// Type definitions
{{- range $object := .Objects }}
/**
 * @typedef {Object} {{ $object.Name }}
{{- range $field := $object.Fields }}
 * @property{{- if $field.Nullable }} {{ printf "{%s|null}" $field.Type }}{{ else }} {{ printf "{%s}" $field.Type }}{{ end }} {{ if $field.Optional }}[{{ $field.Name }}]{{ else }}{{ $field.Name }}{{ end }}{{ if $field.Doc }} - {{ $field.Doc }}{{ end }}
{{- end }}
 */

{{- end }}

/**
 * @param {string} [basepath="/"]
 * @returns {object}
 */
export function createClient(basepath = "/") {
	return {
{{- range $service := .Services }}
		{{ $service.Name }}: {
{{- range $method := $service.Methods }}
			/**
{{- if $method.Summary }}
			 * {{ $method.Summary }}
			 *
{{- end }}
{{- if $method.PathParams }}
			 * @param {Object} pathParams
{{- end }}
{{- if $method.HasBody }}
			 * @param { {{- if $method.RequestType }}{{ $method.RequestType }}{{ else }}any{{ end }} } [request]
{{- end }}
			 * @param {AuthOptions} [options]
			 * @returns {Promise<{{- if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}any{{ end }}>}
			 */
			async {{ $method.Name }}({{ if $method.PathParams }}pathParams, {{ end }}{{ if $method.HasBody }}request, {{ end }}options) {
				const headers = {
					"Accept": "application/json",
					"Content-Type": "application/json",
				}
				let url = basepath + "{{ $method.Path }}"
{{- if $method.PathParams }}
				if (!pathParams) {
					throw new Error("pathParams is required")
				}
{{- range $param := $method.PathParams }}
				url = url.replace("{{ printf "{%s}" $param }}", encodeURIComponent(String(pathParams.{{ $param }})))
{{- end }}
{{- end }}
{{- if $method.HasAuth }}
				const authValue = options && options.auth
				if (authValue) {
{{- if eq $method.Auth.In "header" }}
					headers["{{ $method.Auth.Param }}"] = {{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue
{{- end }}
{{- if eq $method.Auth.In "query" }}
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + encodeURIComponent("{{ $method.Auth.Param }}") + "=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
					document.cookie = "{{ $method.Auth.Param }}=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue) + "; path=/"
{{- end }}
				}
{{- end }}
				const response = await fetch(url, {
					method: "{{ $method.HTTPMethod }}",
					headers,
{{- if $method.HasAuth }}
{{- if eq $method.Auth.In "cookie" }}
					credentials: "same-origin",
{{- end }}
{{- end }}
{{- if $method.HasBody }}
					body: JSON.stringify(request || {}),
{{- end }}
				})
				const text = await response.text()
				let json = null
				if (text) {
					try {
						json = JSON.parse(text)
					} catch (e) {
						if (!response.ok) {
							throw new Error(response.status + " " + response.statusText)
						}
						throw e
					}
				}
				if (!response.ok) {
					if (json && json.error) {
						throw new Error(json.error)
					}
					throw new Error(response.status + " " + response.statusText)
				}
				return json || {}
			},
{{- end }}
		},
{{- end }}
	}
}
`))

// WriteClientJS writes a runtime-generated JS client to w.
func (r *Router) WriteClientJS(w io.Writer) error {
	spec := buildClientSpec(r.Routes(), r.typeOverrides)
	return clientJSTemplate.Execute(w, spec)
}

// WriteClientJSFile writes a runtime-generated JS client to the file at path.
func (r *Router) WriteClientJSFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientJS(f)
}

// ServeClientJS writes a runtime-generated JS client as an HTTP response.
func (r *Router) ServeClientJS(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/javascript")
	if err := r.WriteClientJS(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}
