package virtuous

import (
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientPyTemplate = template.Must(template.New("virtuous-py").Parse(`# Code generated by Virtuous runtime; DO NOT EDIT.

"""Runtime-generated Python client for Virtuous routes."""

from dataclasses import dataclass, fields, is_dataclass
from datetime import datetime
import http
import json
import types
from typing import Any, Union, get_args, get_origin, get_type_hints
from urllib import error, parse, request

# Type definitions
{{- range $i, $object := .Objects }}
{{- if gt $i 0 }}{{ "\n" }}{{ end }}
@dataclass
class {{ $object.Name }}:
{{- if not $object.Fields }}
    pass
{{- else }}
{{- range $field := $object.Fields }}
{{- if $field.Doc }}
    # {{ $field.Doc }}
{{- end }}
    {{ $field.Name }}: {{ $field.Type }}{{ if or $field.Optional $field.Nullable }} | None = None{{ end }}
{{- end }}
{{- end }}

{{- end }}

{{- range $service := .Services }}
class _{{ $service.Name }}Service:
    def __init__(self, basepath: str):
        self._basepath = basepath

{{- range $method := $service.Methods }}
    def {{ $method.Name }}(self{{- if $method.PathParams }}{{- range $param := $method.PathParams }}, {{ $param }}: str{{- end }}{{- end }}{{- if $method.HasBody }}, body: {{- if $method.RequestType }}{{ $method.RequestType }}{{- else }}Any{{- end }} | None = None{{- end }}{{- if $method.HasAuth }}, {{ $method.AuthParam }}: str | None = None{{- end }}) -> {{- if $method.ResponseType }}{{ $method.ResponseType }}{{- else }}None{{- end }}:
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "{{ $method.Path }}"
{{- if $method.PathParams }}
{{- range $param := $method.PathParams }}
        url = url.replace("{{ printf "{%s}" $param }}", parse.quote(str({{ $param }})))
{{- end }}
{{- end }}
{{- if $method.HasAuth }}
        if {{ $method.AuthParam }} is not None:
            auth_value = {{ $method.AuthParam }}
{{- if ne $method.Auth.Prefix "" }}
            auth_value = "{{ $method.Auth.Prefix }} " + {{ $method.AuthParam }}
{{- end }}
{{- if eq $method.Auth.In "header" }}
            headers["{{ $method.Auth.Param }}"] = auth_value
{{- end }}
{{- if eq $method.Auth.In "query" }}
            url = _append_query(url, "{{ $method.Auth.Param }}", auth_value)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
            headers["Cookie"] = "{{ $method.Auth.Param }}=" + parse.quote(auth_value)
{{- end }}
{{- end }}
        data = None
{{- if $method.HasBody }}
        if body is not None:
            data = json.dumps(_encode_value(body)).encode("utf-8")
{{- end }}
        req = request.Request(url, data=data, method="{{ $method.HTTPMethod }}", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
{{- if $method.ResponseType }}
        return _decode_value({{ $method.ResponseType }}, body)
{{- else }}
        return None
{{- end }}

{{- end }}
{{- end }}

class Client:
    def __init__(self, basepath: str = "/"):
        self._basepath = basepath
{{- range $service := .Services }}
        self.{{ $service.Name }} = _{{ $service.Name }}Service(basepath)
{{- end }}


def create_client(basepath: str = "/") -> Client:
    return Client(basepath)


def _status_text(code: int) -> str:
    try:
        return http.HTTPStatus(code).phrase
    except ValueError:
        return "HTTP error"


def _decode_value(tp: Any, value: Any) -> Any:
    if value is None:
        return None
    origin = get_origin(tp)
    if origin is None:
        if is_dataclass(tp):
            return _decode_dataclass(tp, value)
        return value
    if origin is list:
        args = get_args(tp)
        elem_type = args[0] if args else Any
        return [_decode_value(elem_type, item) for item in value]
    if origin is dict:
        args = get_args(tp)
        value_type = args[1] if len(args) > 1 else Any
        return {key: _decode_value(value_type, item) for key, item in value.items()}
    if origin in (Union, types.UnionType):
        args = [arg for arg in get_args(tp) if arg is not type(None)]
        if len(args) == 1:
            return _decode_value(args[0], value)
        return value
    return value


def _decode_dataclass(cls: type[Any], data: Any) -> Any:
    if data is None:
        return None
    if not isinstance(data, dict):
        return data
    type_hints = get_type_hints(cls)
    kwargs: dict[str, Any] = {}
    for field in fields(cls):
        if field.name in data:
            field_type = type_hints.get(field.name, Any)
            kwargs[field.name] = _decode_value(field_type, data[field.name])
    return cls(**kwargs)


def _encode_value(value: Any) -> Any:
    if value is None:
        return None
    if is_dataclass(value):
        return {field.name: _encode_value(getattr(value, field.name)) for field in fields(value)}
    if isinstance(value, list):
        return [_encode_value(item) for item in value]
    if isinstance(value, dict):
        return {key: _encode_value(item) for key, item in value.items()}
    return value


def _append_query(url: str, key: str, value: str) -> str:
    parts = parse.urlsplit(url)
    query = parse.parse_qsl(parts.query, keep_blank_values=True)
    query.append((key, value))
    new_query = parse.urlencode(query)
    return parse.urlunsplit((parts.scheme, parts.netloc, parts.path, new_query, parts.fragment))
`))

// WriteClientPY writes a runtime-generated Python client to w.
func (r *Router) WriteClientPY(w io.Writer) error {
	body, err := r.clientPYBody()
	if err != nil {
		return err
	}
	hash := hashClientBytes(body)
	if _, err := io.WriteString(w, "# Virtuous client hash: "+hash+"\n"); err != nil {
		return err
	}
	_, err = w.Write(body)
	return err
}

// WriteClientPYFile writes a runtime-generated Python client to the file at path.
func (r *Router) WriteClientPYFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientPY(f)
}

// WriteClientPYHash writes the hash of the Python client output to w.
func (r *Router) WriteClientPYHash(w io.Writer) error {
	hash, err := r.clientPYHash()
	if err != nil {
		return err
	}
	_, err = io.WriteString(w, hash)
	return err
}

// ServeClientPY writes a runtime-generated Python client as an HTTP response.
func (r *Router) ServeClientPY(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/x-python; charset=utf-8")
	if err := r.WriteClientPY(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

// ServeClientPYHash writes the hash of the Python client as an HTTP response.
func (r *Router) ServeClientPYHash(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	if err := r.WriteClientPYHash(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

func (r *Router) clientPYBody() ([]byte, error) {
	spec := buildPythonClientSpec(r.Routes(), r.typeOverrides)
	return renderClientTemplate(clientPyTemplate, spec)
}

func (r *Router) clientPYHash() (string, error) {
	body, err := r.clientPYBody()
	if err != nil {
		return "", err
	}
	return hashClientBytes(body), nil
}
