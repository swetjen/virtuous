package httpapi

import (
	"github.com/swetjen/virtuous/internal/clientgen"
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientJSTemplate = template.Must(template.New("virtuous-js").Parse(`// Code generated by Virtuous; DO NOT EDIT.

/**
 * @typedef {Object} AuthOptions
 * @property {string} [auth]
 */

// Type definitions
{{- range $object := .Objects }}
/**
 * @typedef {Object} {{ $object.Name }}
{{- range $field := $object.Fields }}
 * @property{{- if $field.Nullable }} {{ printf "{%s|null}" $field.Type }}{{ else }} {{ printf "{%s}" $field.Type }}{{ end }} {{ if $field.Optional }}[{{ $field.Name }}]{{ else }}{{ $field.Name }}{{ end }}{{ if $field.Doc }} - {{ $field.Doc }}{{ end }}
{{- end }}
 */

{{- end }}

/**
 * @param {string} [basepath="/"]
 * @returns {object}
 */
export function createClient(basepath = "/") {
	return {
{{- range $service := .Services }}
		{{ $service.Name }}: {
{{- range $method := $service.Methods }}
			/**
{{- if $method.Summary }}
			 * {{ $method.Summary }}
			 *
{{- end }}
{{- if $method.PathParams }}
			 * @param {Object} pathParams
{{- end }}
{{- if $method.HasBody }}
			 * @param { {{- if $method.RequestType }}{{ $method.RequestType }}{{ else }}any{{ end }} } [request]
{{- end }}
{{- if $method.HasQuery }}
			 * @param {Object} [query]
{{- range $param := $method.QueryParams }}
			 * @param { {{- if $param.IsArray }}string[]{{ else }}string{{ end }} }{{ if $param.Optional }} [{{ printf "query.%s" $param.Name }}]{{ else }} {{ printf "query.%s" $param.Name }}{{ end }}{{ if $param.Doc }} - {{ $param.Doc }}{{ end }}
{{- end }}
{{- end }}
			 * @param {AuthOptions} [options]
			 * @returns {Promise<{{- if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}any{{ end }}>}
			 */
			async {{ $method.Name }}({{ if $method.PathParams }}pathParams, {{ end }}{{ if $method.HasBody }}request, {{ end }}{{ if $method.HasQuery }}query, {{ end }}options) {
				const headers = {
					"Accept": "application/json",
					"Content-Type": "application/json",
				}
				let url = basepath + "{{ $method.Path }}"
{{- if $method.PathParams }}
				if (!pathParams) {
					throw new Error("pathParams is required")
				}
{{- range $param := $method.PathParams }}
				url = url.replace("{{ printf "{%s}" $param }}", encodeURIComponent(String(pathParams.{{ $param }})))
{{- end }}
{{- end }}
{{- if $method.HasQuery }}
				const queryParts = []
				const appendQuery = (key, value, optional) => {
					if (value === undefined || value === null) {
						if (optional) {
							return
						}
						queryParts.push(encodeURIComponent(key) + "=")
						return
					}
					if (Array.isArray(value)) {
						if (value.length === 0) {
							if (!optional) {
								queryParts.push(encodeURIComponent(key) + "=")
							}
							return
						}
						for (const item of value) {
							if (optional && (item === "" || item === 0 || item === false || item === null || item === undefined)) {
								continue
							}
							const encoded = item === null || item === undefined ? "" : String(item)
							queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(encoded))
						}
						return
					}
					if (optional && (value === "" || value === 0 || value === false)) {
						return
					}
					queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(String(value)))
				}
{{- range $param := $method.QueryParams }}
				appendQuery("{{ $param.Name }}", query && query.{{ $param.Name }}, {{ if $param.Optional }}true{{ else }}false{{ end }})
{{- end }}
				if (queryParts.length > 0) {
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + queryParts.join("&")
				}
{{- end }}
{{- if $method.HasAuth }}
				const authValue = options && options.auth
				if (authValue) {
{{- if eq $method.Auth.In "header" }}
					headers["{{ $method.Auth.Param }}"] = {{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue
{{- end }}
{{- if eq $method.Auth.In "query" }}
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + encodeURIComponent("{{ $method.Auth.Param }}") + "=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
					document.cookie = "{{ $method.Auth.Param }}=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue) + "; path=/"
{{- end }}
				}
{{- end }}
				const response = await fetch(url, {
					method: "{{ $method.HTTPMethod }}",
					headers,
{{- if $method.HasAuth }}
{{- if eq $method.Auth.In "cookie" }}
					credentials: "same-origin",
{{- end }}
{{- end }}
{{- if $method.HasBody }}
					body: JSON.stringify(request || {}),
{{- end }}
				})
				const text = await response.text()
				let json = null
				if (text) {
					try {
						json = JSON.parse(text)
					} catch (e) {
						if (!response.ok) {
							throw new Error(response.status + " " + response.statusText)
						}
						throw e
					}
				}
				if (!response.ok) {
					if (json && json.error) {
						throw new Error(json.error)
					}
					throw new Error(response.status + " " + response.statusText)
				}
				return json || {}
			},
{{- end }}
		},
{{- end }}
	}
}
`))

// WriteClientJS writes a generated JS client to w.
func (r *Router) WriteClientJS(w io.Writer) error {
	body, err := r.clientJSBody()
	if err != nil {
		return err
	}
	hash := clientgen.HashBytes(body)
	if _, err := io.WriteString(w, "// Virtuous client hash: "+hash+"\n"); err != nil {
		return err
	}
	_, err = w.Write(body)
	return err
}

// WriteClientJSFile writes a generated JS client to the file at path.
func (r *Router) WriteClientJSFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientJS(f)
}

// WriteClientJSHash writes the hash of the JS client output to w.
func (r *Router) WriteClientJSHash(w io.Writer) error {
	hash, err := r.clientJSHash()
	if err != nil {
		return err
	}
	_, err = io.WriteString(w, hash)
	return err
}

// ServeClientJS writes a generated JS client as an HTTP response.
func (r *Router) ServeClientJS(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/javascript")
	if err := r.WriteClientJS(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

// ServeClientJSHash writes the hash of the JS client as an HTTP response.
func (r *Router) ServeClientJSHash(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	if err := r.WriteClientJSHash(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

func (r *Router) clientJSBody() ([]byte, error) {
	spec, err := buildClientSpec(r.Routes(), r.typeOverrides)
	if err != nil {
		return nil, err
	}
	return clientgen.RenderTemplate(clientJSTemplate, spec)
}

func (r *Router) clientJSHash() (string, error) {
	body, err := r.clientJSBody()
	if err != nil {
		return "", err
	}
	return clientgen.HashBytes(body), nil
}
