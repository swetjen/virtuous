package httpapi

import (
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientTSTemplate = template.Must(template.New("virtuous-ts").Parse(`// Code generated by Virtuous; DO NOT EDIT.

export type AuthOptions = {
	auth?: string
}
{{range $object := .Objects}}
export interface {{$object.Name}} {
{{- range $field := $object.Fields}}
	{{$field.Name}}{{if $field.Optional}}?{{end}}: {{$field.Type}}{{if $field.Nullable}} | null{{end}};
{{- end}}
}
{{end}}
export function createClient(basepath: string = "/") {
	return {
{{- range $service := .Services }}
		{{ $service.Name }}: {
{{- range $method := $service.Methods }}
			async {{ $method.Name }}({{ if $method.PathParams }}pathParams: { {{- range $param := $method.PathParams }}{{ $param }}: string; {{- end }} }, {{ end }}{{ if $method.HasBody }}request: {{ $method.RequestType }}, {{ end }}{{ if $method.HasQuery }}query?: { {{- range $param := $method.QueryParams }}{{ $param.Name }}{{ if $param.Optional }}?{{ end }}: {{ if $param.IsArray }}string[]{{ else }}string{{ end }}; {{- end }} }, {{ end }}options?: AuthOptions): Promise<{{ if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}void{{ end }}> {
				const headers: Record<string, string> = {
					"Accept": "application/json",
					"Content-Type": "application/json",
				}
				let url = basepath + "{{ $method.Path }}"
{{- if $method.PathParams }}
				if (!pathParams) {
					throw new Error("pathParams is required")
				}
{{- range $param := $method.PathParams }}
				url = url.replace("{{ printf "{%s}" $param }}", encodeURIComponent(String(pathParams.{{ $param }})))
{{- end }}
{{- end }}
{{- if $method.HasQuery }}
				const queryParts: string[] = []
				const appendQuery = (key: string, value: unknown, optional: boolean) => {
					if (value === undefined || value === null) {
						if (optional) {
							return
						}
						queryParts.push(encodeURIComponent(key) + "=")
						return
					}
					if (Array.isArray(value)) {
						if (value.length === 0) {
							if (!optional) {
								queryParts.push(encodeURIComponent(key) + "=")
							}
							return
						}
						for (const item of value) {
							if (optional && (item === "" || item === 0 || item === false || item === null || item === undefined)) {
								continue
							}
							const encoded = item === null || item === undefined ? "" : String(item)
							queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(encoded))
						}
						return
					}
					if (optional && (value === "" || value === 0 || value === false)) {
						return
					}
					queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(String(value)))
				}
{{- range $param := $method.QueryParams }}
				appendQuery("{{ $param.Name }}", query && query.{{ $param.Name }}, {{ if $param.Optional }}true{{ else }}false{{ end }})
{{- end }}
				if (queryParts.length > 0) {
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + queryParts.join("&")
				}
{{- end }}
{{- if $method.HasAuth }}
				const authValue = options && options.auth
				if (authValue) {
{{- if eq $method.Auth.In "header" }}
					headers["{{ $method.Auth.Param }}"] = {{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue
{{- end }}
{{- if eq $method.Auth.In "query" }}
					const sep = url.includes("?") ? "&" : "?"
					url = url + sep + encodeURIComponent("{{ $method.Auth.Param }}") + "=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue)
{{- end }}
{{- if eq $method.Auth.In "cookie" }}
					document.cookie = "{{ $method.Auth.Param }}=" + encodeURIComponent({{ if ne $method.Auth.Prefix "" }}"{{ $method.Auth.Prefix }} " + {{ end }}authValue) + "; path=/"
{{- end }}
				}
{{- end }}
				const response = await fetch(url, {
					method: "{{ $method.HTTPMethod }}",
					headers,
{{- if $method.HasAuth }}
{{- if eq $method.Auth.In "cookie" }}
					credentials: "same-origin",
{{- end }}
{{- end }}
{{- if $method.HasBody }}
					body: JSON.stringify(request || {}),
{{- end }}
				})
				const text = await response.text()
				let json: {{ if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}Record<string, unknown>{{ end }} | null = null
				if (text) {
					try {
						json = JSON.parse(text)
					} catch (e) {
						if (!response.ok) {
							throw new Error(response.status + " " + response.statusText)
						}
						throw e
					}
				}
				if (!response.ok) {
					const errorBody = json as { error?: string } | null
					if (errorBody && errorBody.error) {
						throw new Error(errorBody.error)
					}
					throw new Error(response.status + " " + response.statusText)
				}
				return json as {{ if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}void{{ end }}
			},
{{- end }}
		},
{{- end }}
	}
}
`))

// WriteClientTS writes a generated TS client to w.
func (r *Router) WriteClientTS(w io.Writer) error {
	body, err := r.clientTSBody()
	if err != nil {
		return err
	}
	hash := hashClientBytes(body)
	if _, err := io.WriteString(w, "// Virtuous client hash: "+hash+"\n"); err != nil {
		return err
	}
	_, err = w.Write(body)
	return err
}

// WriteClientTSFile writes a generated TS client to the file at path.
func (r *Router) WriteClientTSFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientTS(f)
}

// WriteClientTSHash writes the hash of the TS client output to w.
func (r *Router) WriteClientTSHash(w io.Writer) error {
	hash, err := r.clientTSHash()
	if err != nil {
		return err
	}
	_, err = io.WriteString(w, hash)
	return err
}

// ServeClientTS writes a generated TS client as an HTTP response.
func (r *Router) ServeClientTS(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/typescript")
	if err := r.WriteClientTS(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

// ServeClientTSHash writes the hash of the TS client as an HTTP response.
func (r *Router) ServeClientTSHash(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	if err := r.WriteClientTSHash(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

func (r *Router) clientTSBody() ([]byte, error) {
	spec, err := buildClientSpec(r.Routes(), r.typeOverrides)
	if err != nil {
		return nil, err
	}
	return renderClientTemplate(clientTSTemplate, spec)
}

func (r *Router) clientTSHash() (string, error) {
	body, err := r.clientTSBody()
	if err != nil {
		return "", err
	}
	return hashClientBytes(body), nil
}
