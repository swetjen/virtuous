package httpapi

import (
	"io"
	"net/http"
	"os"
	"text/template"
)

var clientJSLiteTemplate = template.Must(template.New("virtuous-js-lite").Parse(`// Code generated by Virtuous; DO NOT EDIT.

import { useMutation, useQuery } from "@tanstack/react-query";

/**
 * @typedef {Object} ClientOptions
 * @property {string} [baseUrl]
 * @property {string} [auth]
 * @property {(input: RequestInfo, init?: RequestInit) => Promise<Response>} [fetcher]
 */

/**
 * @typedef {Object} RequestOptions
 * @property {Object} [path]
 * @property {Object} [query]
 * @property {Object} [body]
 * @property {string} [auth]
 * @property {Object} [headers]
 * @property {AbortSignal} [signal]
 */

// Type definitions
{{- range $object := .Objects }}
/**
 * @typedef {Object} {{ $object.Name }}
{{- range $field := $object.Fields }}
 * @property{{- if $field.Nullable }} {{ printf "{%s|null}" $field.Type }}{{ else }} {{ printf "{%s}" $field.Type }}{{ end }} {{ if $field.Optional }}[{{ $field.Name }}]{{ else }}{{ $field.Name }}{{ end }}{{ if $field.Doc }} - {{ $field.Doc }}{{ end }}
{{- end }}
 */

{{- end }}

let defaultClient = null;

/**
 * @param {ClientOptions} [options]
 */
export function configureClient(options = {}) {
	defaultClient = createClient(options);
	return defaultClient;
}

export function getClient() {
	if (!defaultClient) {
		defaultClient = createClient();
	}
	return defaultClient;
}

/**
 * @param {ClientOptions} [options]
 */
export function createClient(options = {}) {
	const baseUrl = options.baseUrl || "/";
	const defaultAuth = options.auth;
	const fetcher = options.fetcher || fetch;

	const appendQuery = (queryParts, key, value, optional) => {
		if (value === undefined || value === null) {
			if (optional) {
				return;
			}
			queryParts.push(encodeURIComponent(key) + "=");
			return;
		}
		if (Array.isArray(value)) {
			if (value.length === 0) {
				if (!optional) {
					queryParts.push(encodeURIComponent(key) + "=");
				}
				return;
			}
			for (const item of value) {
				if (optional && (item === "" || item === 0 || item === false || item === null || item === undefined)) {
					continue;
				}
				const encoded = item === null || item === undefined ? "" : String(item);
				queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(encoded));
			}
			return;
		}
		if (optional && (value === "" || value === 0 || value === false)) {
			return;
		}
		queryParts.push(encodeURIComponent(key) + "=" + encodeURIComponent(String(value)));
	};

	const request = async ({ method, path, pathParams, query, body, auth, headers, signal }) => {
		let url = baseUrl + path;
		if (pathParams) {
{{- range $service := .Services }}
{{- range $method := $service.Methods }}
			if (path === "{{ $method.Path }}") {
{{- if $method.PathParams }}
				if (!pathParams) {
					return { data: null, error: { message: "path params are required", status: 0, body: null }, status: 0, ok: false };
				}
{{- range $param := $method.PathParams }}
				url = url.replace("{{ printf "{%s}" $param }}", encodeURIComponent(String(pathParams.{{ $param }})));
{{- end }}
{{- end }}
			}
{{- end }}
{{- end }}
		}

		if (query) {
			const queryParts = [];
{{- range $service := .Services }}
{{- range $method := $service.Methods }}
			if (path === "{{ $method.Path }}") {
{{- if $method.HasQuery }}
{{- range $param := $method.QueryParams }}
				appendQuery(queryParts, "{{ $param.Name }}", query.{{ $param.Name }}, {{ if $param.Optional }}true{{ else }}false{{ end }});
{{- end }}
{{- end }}
			}
{{- end }}
{{- end }}
			if (queryParts.length > 0) {
				const sep = url.includes("?") ? "&" : "?";
				url = url + sep + queryParts.join("&");
			}
		}

		const reqHeaders = {
			"Accept": "application/json",
			"Content-Type": "application/json",
			...(headers || {}),
		};

		const authValue = auth || defaultAuth;
		if (authValue) {
			{{- /* auth is always header for httpapi */}}
			reqHeaders["Authorization"] = "Bearer " + authValue;
		}

		try {
			const response = await fetcher(url, {
				method,
				headers: reqHeaders,
				signal,
				{{- /* only include body when provided */}}
				{{- /* body passed through */}}
				body: body ? JSON.stringify(body) : undefined,
			});
			const text = await response.text();
			let json = null;
			if (text) {
				try {
					json = JSON.parse(text);
				} catch (e) {
					if (!response.ok) {
						return { data: null, error: { message: response.status + " " + response.statusText, status: response.status, body: text }, status: response.status, ok: false };
					}
					return { data: null, error: { message: "invalid JSON response", status: response.status, body: text }, status: response.status, ok: false };
				}
			}
			if (!response.ok) {
				const message = (json && (json.error || json.message)) || (response.status + " " + response.statusText);
				return { data: null, error: { message, status: response.status, body: json || text }, status: response.status, ok: false };
			}
			return { data: json || {}, error: null, status: response.status, ok: true };
		} catch (err) {
			return { data: null, error: { message: String(err), status: 0, body: null }, status: 0, ok: false };
		}
	};

	return {
{{- range $service := .Services }}
{{- range $method := $service.Methods }}
		/**
{{- if $method.Summary }}
		 * {{ $method.Summary }}
		 *
{{- end }}
		 * @param {RequestOptions} [options]
		 * @returns {Promise<{data: {{- if $method.ResponseType }}{{ $method.ResponseType }}{{ else }}any{{ end }}, error: {message: string, status: number, body: any}|null, status: number, ok: boolean}>}
		 */
		{{ $method.FlatName }}(options = {}) {
			const { path, query, body, auth, headers, signal } = options;
			return request({
				method: "{{ $method.HTTPMethod }}",
				path: "{{ $method.Path }}",
				pathParams: path,
				query,
{{- if $method.HasBody }}
				body,
{{- else }}
				body: undefined,
{{- end }}
				auth,
				headers,
				signal,
			});
		},
{{- end }}
{{- end }}
	};
}

// Hooks
{{- range $service := .Services }}
{{- range $method := $service.Methods }}
/**
 * @param {Object} [options]
 */
export function use{{ $method.FlatName }}(options = {}) {
	const client = options.client || getClient();
{{- if eq $method.HTTPMethod "GET" }}
	const query = useQuery({
		queryKey: ["{{ $method.FlatName }}", options.request?.path, options.request?.query],
		queryFn: () => client.{{ $method.FlatName }}(options.request),
		...(options.query || {}),
	});
	const result = query.data || { data: null, error: null, status: 0, ok: false };
	return {
		data: result.data,
		error: result.error || query.error || null,
		status: result.status,
		ok: result.ok,
		isLoading: query.isLoading,
		isError: query.isError,
		isSuccess: query.isSuccess,
		refetch: query.refetch,
	};
{{- else }}
	const mutation = useMutation({
		mutationFn: (requestOptions) => client.{{ $method.FlatName }}(requestOptions),
		...(options.mutation || {}),
	});
	const result = mutation.data || { data: null, error: null, status: 0, ok: false };
	return {
		data: result.data,
		error: result.error || mutation.error || null,
		status: result.status,
		ok: result.ok,
		isLoading: mutation.isLoading,
		isError: mutation.isError,
		isSuccess: mutation.isSuccess,
		mutate: mutation.mutate,
		mutateAsync: mutation.mutateAsync,
		reset: mutation.reset,
	};
{{- end }}
}

{{- end }}
{{- end }}
`))

// WriteClientJSLite writes the lightweight JS client to w.
func (r *Router) WriteClientJSLite(w io.Writer) error {
	body, err := r.clientJSLiteBody()
	if err != nil {
		return err
	}
	hash := hashClientBytes(body)
	if _, err := io.WriteString(w, "// Virtuous client hash: "+hash+"\n"); err != nil {
		return err
	}
	_, err = w.Write(body)
	return err
}

// WriteClientJSLiteFile writes the lightweight JS client to the file at path.
func (r *Router) WriteClientJSLiteFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return r.WriteClientJSLite(f)
}

// ServeClientJSLite writes the lightweight JS client as an HTTP response.
func (r *Router) ServeClientJSLite(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/javascript")
	if err := r.WriteClientJSLite(w); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

func (r *Router) clientJSLiteBody() ([]byte, error) {
	spec, err := buildClientSpec(r.Routes(), r.typeOverrides)
	if err != nil {
		return nil, err
	}
	return renderClientTemplate(clientJSLiteTemplate, spec)
}
