# Code generated by Virtuous runtime; DO NOT EDIT.

"""Runtime-generated Python client for Virtuous routes."""

from dataclasses import dataclass, fields, is_dataclass
from datetime import datetime
import http
import json
import types
from typing import Any, Union, get_args, get_origin, get_type_hints
from urllib import error, parse, request

# Type definitions
@dataclass
class CreateUserRequest:
    email: str
    name: str
    role: str

@dataclass
class State:
    # Numeric state ID.
    id: int
    # Two-letter state code.
    code: str
    # Display name for the state.
    name: str

@dataclass
class StateResponse:
    state: "State"
    error: str | None = None

@dataclass
class StatesResponse:
    data: list["State"]
    error: str | None = None

@dataclass
class User:
    # User ID.
    id: int
    # Login email address.
    email: str
    # Display name.
    name: str
    # Authorization role.
    role: str

@dataclass
class UserResponse:
    user: "User"
    error: str | None = None

@dataclass
class UsersResponse:
    data: list["User"]
    error: str | None = None
class _StatesService:
    def __init__(self, basepath: str):
        self._basepath = basepath
    def getByCode(self, code: str) ->"StateResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/lookup/states/{code}"
        url = url.replace("{code}", parse.quote(str(code)))
        data = None
        req = request.Request(url, data=data, method="GET", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("StateResponse", body)
    def getByCodeSecure(self, code: str, bearerAuth: str | None = None) ->"StateResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/secure/states/{code}"
        url = url.replace("{code}", parse.quote(str(code)))
        if bearerAuth is not None:
            auth_value = bearerAuth
            auth_value = "Bearer " + bearerAuth
            headers["Authorization"] = auth_value
        data = None
        req = request.Request(url, data=data, method="GET", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("StateResponse", body)
    def getMany(self) ->"StatesResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/lookup/states/"
        data = None
        req = request.Request(url, data=data, method="GET", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("StatesResponse", body)
class _UsersService:
    def __init__(self, basepath: str):
        self._basepath = basepath
    def create(self, body:"CreateUserRequest" | None = None, bearerAuth: str | None = None) ->"UserResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/admin/users"
        if bearerAuth is not None:
            auth_value = bearerAuth
            auth_value = "Bearer " + bearerAuth
            headers["Authorization"] = auth_value
        data = None
        if body is not None:
            data = json.dumps(_encode_value(body)).encode("utf-8")
        req = request.Request(url, data=data, method="POST", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("UserResponse", body)
    def getByID(self, id: str, bearerAuth: str | None = None) ->"UserResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/admin/users/{id}"
        url = url.replace("{id}", parse.quote(str(id)))
        if bearerAuth is not None:
            auth_value = bearerAuth
            auth_value = "Bearer " + bearerAuth
            headers["Authorization"] = auth_value
        data = None
        req = request.Request(url, data=data, method="GET", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("UserResponse", body)
    def getMany(self, bearerAuth: str | None = None) ->"UsersResponse":
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        url = self._basepath + "/api/v1/admin/users"
        if bearerAuth is not None:
            auth_value = bearerAuth
            auth_value = "Bearer " + bearerAuth
            headers["Authorization"] = auth_value
        data = None
        req = request.Request(url, data=data, method="GET", headers=headers)
        status = 0
        text = ""
        try:
            with request.urlopen(req) as resp:
                status = resp.getcode()
                text = resp.read().decode("utf-8")
        except error.HTTPError as err:
            status = err.code
            text = err.read().decode("utf-8")
        body = None
        if text:
            try:
                body = json.loads(text)
            except json.JSONDecodeError as err:
                if status >= 400:
                    raise RuntimeError(f"{status} {_status_text(status)}") from err
                raise
        if status >= 400:
            if isinstance(body, dict) and "error" in body:
                raise RuntimeError(str(body["error"]))
            raise RuntimeError(f"{status} {_status_text(status)}")
        return _decode_value("UsersResponse", body)

class Client:
    def __init__(self, basepath: str = "/"):
        self._basepath = basepath
        self.States = _StatesService(basepath)
        self.Users = _UsersService(basepath)


def create_client(basepath: str = "/") -> Client:
    return Client(basepath)


def _status_text(code: int) -> str:
    try:
        return http.HTTPStatus(code).phrase
    except ValueError:
        return "HTTP error"


def _decode_value(tp: Any, value: Any) -> Any:
    if value is None:
        return None
    origin = get_origin(tp)
    if origin is None:
        if is_dataclass(tp):
            return _decode_dataclass(tp, value)
        return value
    if origin is list:
        args = get_args(tp)
        elem_type = args[0] if args else Any
        return [_decode_value(elem_type, item) for item in value]
    if origin is dict:
        args = get_args(tp)
        value_type = args[1] if len(args) > 1 else Any
        return {key: _decode_value(value_type, item) for key, item in value.items()}
    if origin in (Union, types.UnionType):
        args = [arg for arg in get_args(tp) if arg is not type(None)]
        if len(args) == 1:
            return _decode_value(args[0], value)
        return value
    return value


def _decode_dataclass(cls: type[Any], data: Any) -> Any:
    if data is None:
        return None
    if not isinstance(data, dict):
        return data
    type_hints = get_type_hints(cls)
    kwargs: dict[str, Any] = {}
    for field in fields(cls):
        if field.name in data:
            field_type = type_hints.get(field.name, Any)
            kwargs[field.name] = _decode_value(field_type, data[field.name])
    return cls(**kwargs)


def _encode_value(value: Any) -> Any:
    if value is None:
        return None
    if is_dataclass(value):
        return {field.name: _encode_value(getattr(value, field.name)) for field in fields(value)}
    if isinstance(value, list):
        return [_encode_value(item) for item in value]
    if isinstance(value, dict):
        return {key: _encode_value(item) for key, item in value.items()}
    return value


def _append_query(url: str, key: str, value: str) -> str:
    parts = parse.urlsplit(url)
    query = parse.parse_qsl(parts.query, keep_blank_values=True)
    query.append((key, value))
    new_query = parse.urlencode(query)
    return parse.urlunsplit((parts.scheme, parts.netloc, parts.path, new_query, parts.fragment))
